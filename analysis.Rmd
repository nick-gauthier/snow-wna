---
title: "Snowpack variability in western North America over the common era"
subtitle: "Models and Observations"
author: "Nick Gauthier"
date: "Last knit on: `r Sys.Date()`"
output:
  tufte::tufte_html: default
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
  tufte::tufte_book:
    citation_package: natbib
    latex_engine: xelatex
bibliography: skeleton.bib
link-citations: yes
---

Analysis of snowpack dynamics in western North America over the Common Era.

## Setup

Import the packages required for this analysis.

```{r}
library(raster) # processing raster data
library(tidyverse) # data manipulation and visualization
library(mgcv) # flexible nonlinear regression models
library(furrr) # parallel processing
library(gganimate) # animated gifs
library(ggridges)
```

Define a study area to constrain all computaitons.
```{r}
bbox <- extent(c(-125, -104, 33, 50))
```

Import the snow observation data from https://nsidc.org/data/nsidc-0719.^[What's up with this warning message? long_name=CRS definition
spatial_ref=GEOGCS["NAD83",DATUM["North_American_Datum_1983",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],AUTHORITY["EPSG","6269"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4269"]]
GeoTransform=-125.0208 0.04166662697178698 0 49.9375 0 -0.04166662697178698]

```{r, message=FALSE,warning=FALSE}
plan(multisession) # setup parallel processing

preprocess <- function(x, var) {
  brick(x, varname = var) %>%
    crop(bbox) %>%
    sum() %>%
    aggregate(fact = 2, na.rm = TRUE)
}

swe_obs <- list.files('data/', pattern = 'SWE_Depth', full.names = TRUE) %>%
  future_map(preprocess, var = 'SWE') %>%
  brick() %>%
  setNames(1982:2017)

depth_obs <- list.files('data/', pattern = 'SWE_Depth', full.names = TRUE) %>%
  future_map(preprocess, var = 'DEPTH') %>%
  brick() %>%
  setNames(1982:2017)
```

Import elevation and resample.
```{r}
elev <- raster('~/gdrive/Data/SRTM_1km.tif') %>%
  crop(bbox) %>%
  resample(swe_obs)
```

Turn the rasters into data frames and join.

```{r}
swe_dat <- swe_obs %>%
  as.data.frame(xy = TRUE, na.rm = TRUE, long = TRUE) %>%
  rename(water_year = layer, SWE = value) %>%
  mutate(x = round(x, 8), y = round(y, 8))

depth_dat <- depth_obs %>%
  as.data.frame(xy = TRUE, na.rm = TRUE, long = TRUE) %>%
  rename(water_year = layer, DEPTH = value) %>%
  mutate(x = round(x, 8), y = round(y, 8))

elev_dat <- elev %>%
  as.data.frame(xy = TRUE, na.rm = TRUE) %>%
  rename(elev = SRTM_1km)

snow_dat <- swe_dat %>%
  left_join(depth_dat, by = c('x', 'y', 'water_year')) %>%
#  left_join(elev_dat, by = c('x', 'y')) %>%
  mutate(water_year = parse_number(water_year))


ggplot(snow_dat, aes(x,y)) +
  geom_raster(aes(fill = DEPTH)) +
  facet_wrap(~water_year)

```





```{r}
m1 <- bam(SWE ~ te(x, y, by = water_year, k = 15), data = filter(snow_dat, SWE > 0))
plot(m1, scheme = 2)
summary(m1)

snow_dat %>%
  filter(SWE > 0) %>%
  filter(water_year == 1999) %>%
  mutate(pred = predict(m1, ., type = 'response')) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = pred))
```


Filter out the 0s
```{r}
swe_dat %>%
  filter(SWE > 0) %>%
ggplot(aes(x = SWE, y = as.factor(water_year), fill = ..x..)) +
  geom_density_ridges_gradient() +
  scale_x_log10() +
  scale_fill_distiller(palette = 'YlGnBu', direction= -1) +
  theme_minimal()
```


Now run a principal components analysis on the observed SPEI data. Much of the code that follows is adapted from the *wql* and *sinkr* packages.

```{r}
obs_pca <- swe_dat %>%
  group_by(x, y) %>%
  mutate(test = all(SWE== 0)) %>%
  filter(test == FALSE) %>%
  ungroup() %>%
  select(-test)%>%
  spread(water_year, SWE) %>%
  select(-x, -y) %>%
  t() %>%
  prcomp(scale. = TRUE)
```

```{r, echo = FALSE}
library(broom)
obs_eigs <- obs_pca %>%
  tidy(matrix = 'pcs') %>%
  mutate(eigenvalues = std.dev ^ 2)
```



```{r plot_variance_obs, fig.width = 5, fig.height = 4, echo = FALSE, fig.cap = 'Percent variance explained by the leading principal components of the observed SPEI record. PCs that are not well separated can be considered effective multiplets due to temporal autocorrelation, and should not be split in truncation.'}
obs_eigs %>% 
    filter(PC <= 12) %>%
ggplot(aes(x = PC, y = percent * 100)) +
  #geom_errorbar(aes(x = PC, ymin = low, ymax = hi), width = 0.4) +
  geom_point(size = 2) + 
 # geom_text(aes(x = PC, y = cumvar_line, label = paste0(round(cumulative * 100, 0), '%')), size = 2.5, vjust = 0) +
  labs(x = "Principal Component", y = "Normalized Eigenvalue") + 
  geom_vline(xintercept = 2.5, linetype = 2, color = 'red', alpha = .7) +
  theme_bw() + 
  guides(color = F) + 
  scale_x_continuous(breaks = seq(0, 12, 2))
```


Define a function to calculate the empirical orthogonal functions and rotated empirical orthogonal functions, as well as their associated PC amplitude time series. Save all relevant information in a list for later use.



Use this function to calculate the EOFs and REOFs for the observations and reconstructions, retaining the 6 leading components in each case for rotation.

```{r calc_eofs}
 eofs <- obs_pca %>% # calculate unrotated EOFs
    tidy(matrix = 'variables') %>%
    filter(PC <= 2) %>%
    left_join(obs_eigs[1:2], by = 'PC') %>%
    mutate(eof = value * std.dev,
           PC = as.character(PC)) %>%
    select(-std.dev, -value) 
```

```{r}
  varim <- eofs %>% # varimax rotation
    pivot_wider(names_from = PC, values_from = eof) %>%
    column_to_rownames(var = 'column') %>%
    as.matrix %>%
    varimax
  rot_mat <- varim$rotmat # rotater
```

```{r}  
reofs <- unclass(varim$loadings) %>%
    as_tibble(rownames = 'column') %>%
    pivot_longer(-column, names_to = 'PC', values_to = 'reof') %>%
  mutate(column = as.numeric(column)) %>%
    right_join(eofs, by = c('column', 'PC'))
  
  eof_amps <- obs_pca$x %>%
    .[,1:2] %>%
    scale %>%
    as_tibble(rownames = 'year', .name_repair = ~1:2) %>%
    gather(PC, eof_amp, -year) %>%
    mutate(year = as.numeric(str_sub(year, 2)),
           PC = as.factor(paste0('PC', PC)))
  
  reof_amps <- obs_pca$x %>%
    .[,1:2] %>%
    scale %>%
    `%*%`(rot_mat) %>%
    as_tibble(rownames = 'year', .name_repair = ~1:n_modes) %>%
    gather(PC, reof_amp, -year) %>%
    mutate(year = as.numeric(str_sub(year, 2)),
           PC = as.factor(paste0('PC', PC)))
```

rotation doesn't do much
```{r}
swe_dat%>%
    group_by(x, y) %>%
  mutate(test = all(SWE== 0)) %>%
  filter(test == FALSE) %>%
  ungroup() %>%
  select(-test) %>%
  spread(water_year, SWE) %>%
  mutate(column = 1:n()) %>%
  select(x, y, column) %>%
  full_join(reofs) %>%
  ggplot(aes(x, y, fill = reof)) +
  geom_raster() +
  facet_wrap(~PC) +
  scale_fill_distiller(palette = 'RdBu') +
  theme_void()+
  coord_quickmap()
```

```{r}
swe_dat%>%
    group_by(x, y) %>%
  mutate(test = all(SWE== 0)) %>%
  filter(test == FALSE) %>%
  ungroup() %>%
  select(-test) %>%
  spread(water_year, SWE) %>%
  mutate(column = 1:n()) %>%
  select(x, y, column) %>%
  full_join(reofs) %>%
  ggplot(aes(x, y, fill = eof)) +
  geom_raster() +
  facet_wrap(~PC) +
  scale_fill_distiller(palette = 'RdBu') +
  theme_void()+
  coord_quickmap()
```

First let's model the relationship between snow depth and snow water equivalent (i.e. snow density) in the observations.

```{r}
snow_dat %>%
  filter(DEPTH < 1e+6) %>%
  ggplot(aes(DEPTH, SWE)) +
  geom_point()


m2 <- bam(SWE ~ s(DEPTH), data = snow_dat, discrete = TRUE)

plot(m2)
summary(m2)

test <- snow_dat %>%
  mutate(error = SWE - predict(m2, .))

test %>%
  filter(water_year %in% 1995:1997) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = error)) +
  scale_fill_viridis_c() +
  facet_wrap(~water_year) +
  coord_quickmap()+
  theme_void()
```
Compare to climatological data for annual temperature range.

```{r}
temp_range <- brick('data/CHELSA_bio10_07.tif') %>%
  crop(bbox)%>%
  `/`(10)

prec_djf <- (raster('data/CHELSA_prec_01_V1.2_land.tif') + 
  raster('data/CHELSA_prec_02_V1.2_land.tif') + 
  raster('data/CHELSA_prec_12_V1.2_land.tif')) %>%
  crop(bbox) %>%
  `/`(3)
```

```{r}
plot(prec_djf)
```

```{r}
plot(temp_range/10)
```


```{r}
swe_dat %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = log(SWE + 1))) +
  scale_fill_viridis_c() +
  coord_quickmap()+
  theme_void() +
  ggtitle("Water Year: {closest_state}") +
  transition_states(water_year)
```


```{r, warning = FALSE}
swe_dat %>%
  group_by(x, y) %>%
  mutate(rho = cor(SWE, lag(SWE), use = 'complete.obs')) %>%
   ggplot(aes(x, y)) +
  geom_raster(aes(fill = rho)) +
  scale_fill_viridis_c() +
  coord_quickmap()+
  theme_void() 
```


```{r}
snow_dat %>%
  group_by(water_year) %>%
  summarise(SWE = sum(SWE, na.rm = TRUE)) %>%
  ggplot(aes(water_year, SWE)) +
  geom_col(aes(fill = SWE)) +
  scale_fill_viridis_c()
```

## Paleo
```{r}
brick('data/trace.01-36.22000BP.cam2.SNOWHLND.22000BP_decavg_400BCE.nc') %>%
  rotate() %>%
  crop(bbox, snap = 'out') %>% plot 

brick('data/trace.01-36.22000BP.clm2.SNOWDP.22000BP_decavg_400BCE.nc', varname = 'SNOWDP') %>%
  rotate() %>%
  crop(bbox, snap = 'out') %>% plot 
```


## Reanalysis
```{r}
ncdf_file <- 'data/adaptor.mars.internal-1566933160.7965047-18657-23-b3ae7b43-15db-4890-bc5b-4d3413fe4ddd.nc'
ref <- brick(ncdf_file, var = 'sd') %>% 
  .[[1]]%>%
  rotate %>%
  crop(bbox)

elev <- resample(elev, ref)

snowdepth <- brick(ncdf_file, var = 'sd') %>% 
  rotate %>%
  crop(bbox) %>%
  mask(elev) %>%
  as.data.frame(xy = TRUE, long = TRUE) %>%
  rename(time = Z, sd = value)

temp <- brick(ncdf_file, var = 't2m') %>% 
  rotate %>%
  crop(bbox) %>%
  mask(elev) %>%
  as.data.frame(xy = TRUE, long = TRUE) %>%
  rename(time = Z, t2m = value)

precip <- brick(ncdf_file, var = 'tp') %>% 
  rotate %>%
  crop(bbox) %>%
  mask(elev) %>%
  as.data.frame(xy = TRUE, long = TRUE) %>%
  rename(time = Z, tp = value)
```



```{r}
dat <- snowdepth %>%
  left_join(temp, by = c('x', 'y', 'time')) %>%
  left_join(precip, by = c('x', 'y', 'time')) %>%
  as_tibble %>%
  separate(time, into = c('year', 'month', 'day'), convert = TRUE) %>%
  select(-day) %>%
  mutate(t2m = t2m - 273.15,
         season = case_when(month %in% c(12, 1, 2) ~ 'DJF',
                            month %in% c(3, 4, 5) ~ 'MAM',
                            month %in% c(6, 7, 8) ~ 'JJA',
                            month %in% c(9, 10, 11) ~ 'SON'))
```

```{r}
ggplot(dat, aes(t2m, sd)) +
  geom_point(alpha = .5) +
  facet_wrap(~season) +
  theme_bw()
```

```{r}
dat2 <- dat %>%
  mutate(water_year = if_else(month < 10, year, year + 1L)) %>%
  filter(between(water_year, 1980, 2018)) %>%
  group_by(x, y, water_year) %>%
  summarise(sd = sum(sd), t2m = mean(t2m), tp = sum(tp))
```


```{r}
dat2 %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = sd)) +
  scale_fill_viridis_c() +
  coord_quickmap()+
  theme_void() +
  ggtitle("Year: {closest_state}") +
  transition_states(water_year)
```

```{r}
dat2 %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = sd)) +
  scale_fill_viridis_c() +
  facet_wrap(~water_year) +
  coord_quickmap()+
  theme_void()
```

```{r}
dat2 %>%
  group_by(water_year) %>%
  summarise(sd = sum(sd, na.rm = TRUE)) %>%
  ggplot(aes(water_year, sd)) +
  geom_col(aes(fill = sd)) +
  scale_fill_viridis_c()
```

```{r}
mod <- dat2 %>%
  mutate(start = if_else(water_year == min(water_year), TRUE, FALSE)) %>%
  filter(sd > 0) %>%
  bam(sd ~ te(t2m, tp) + te(x,y), data = ., AR.start = start)

summary(mod)
plot(mod, scheme = 1)
```
